---
layout: post
title: Getting more targeted
tags: [hacking]
---


## Continuing with the fuzz and getting more targeted

OK folks, back at it this evening (wtf am I a weatherman??). Since I've found ~10 0-days in the Shell32/explorer.exe automation library I think it's time we admit that I'm going to be finding 0-days all fucking day in this thing. So now I need to get a little smarter and choose some targets that are going to make the most impact. How I do dis? Well, we're gonna start using an RE tool (yay?) that lights up the parts of a binary that have been visited. It's called lighthouse, it's primarily used by people that fuzz to ensure that they're getting good coverage after a fuzz run. I don't care about that right now, what I really want is to know which functions are called when I pop open explorer.exe. That way I can target those functions, 0-day one of them (for example one that lists the contents of a folder), try to control that 0-day vuln and write a 0-day exploit for it. Why? Because I can. And because it could also be worth some money. I used to think of this as a dirty practice, but I realized that in reality all this does is make your hunting *sustainable* and we all want me to keep finding 0-days right?? Bug bounties certainly won't cut it, I don't work for 500 bucks for a week's worth of work and an "I <3 microsoft" fucking t-shirt. Anyway let's get at it. First things first, I've downloaded DynamoRIO and I'm going to go ahead and instrument it using drcov. I have Binary Ninja installed (because fuck IDA), and the lighthouse plugin installed. Just follow the instructions, they work. Let's get going on collecting coverage information. Of course another technique I'll use in tandem is simply dynamic analysis, I'll pop a debugger open on explorer.exe and just check out which functions are called. I downloaded all of the necessary symbols in a previous post somewhere in there, but let's do one at a time. To be totally honest I've never tried this lighthouse thing out and I have no idea if it'll work how I think it will, but I've used it for fuzzing purposes before and it's worked nicely there.

OK so I pop open Binary Ninja. Aaaand you know what? I'm fucking tired. I'm picking this back up tomorrow. Later peeps, sorry for the lame duck post.

Alright, so I've lost data a bunch of times trying to test explorer.exe so hopefully this time it makes it. Here's what I did, I went ahead and downloaded all symbols by using the Microsoft Symbol Downloader, which makes quick work of stuff, and I've stored everything in C:\symbols. Now I'm going to try a simple operation - open a folder using the explorer.exe command and see if I can make sense of what's going on by using Binary Ninja and/or x64dbg. I've downloaded DynamoRIO and opened a folder like this:

`drrun.exe -t drcov -- explorer.exe doc/`

Then I close the folder. This produces a file called something-coverage.log, then I go ahead and open explorer.exe in BNinja. Right after opening I point it to C:\symbols and tell it to reanalyze, giving me some nice function names in my disassembly. It hsould look something like this:

![shelldisasm](/assets/img/disasm.PNG)

`Great, now I go up to Tools -> lighthouse -> Load Coverage File` and choose my loaded file. For me, this opened a tiny window I couldn't find called the Coverage Explorer, if you don't see it look harder or you can explicitly open it with `Tools -> lighthouse -> Coverage View`. OK cool, so now I have a coverage view of functions that were called in the order that they were called in. It looks like this:

![coverage](/assets/img/cov.PNG)

After a fuckton of scrolling and looking for a function that would cause something interesting to happen I found one possible candidate. I say possible candidate because it may not end up being interesting, and the attack vector may not end up being any good. We'll see though, it'd be a win just to be able to take control of the program and do some nasty stuff. The functions I found were: `SHExplorerParseCmdLine(uint16_t* arg1, struct _ITEMIDLIST_ABSOLUTE** arg2);` which then calls `SHGetFolderLocation(0, 5, 0, 0, pidlAbsolute);`. It looks to me like what's happening is this is parsing the name I feed to the command line and running `SHGetFolderLocation` from it. So let's try to find a vuln in SHGetFolderLocation - from previous research, this library is swiss cheese, so I'd be shocked if I didn't find SOMETHING. Let's go back to my old code and try to do something interesting. I quickly realized I didn't even need that. This time it takes a lot fewer lines:

```
#include <shlobj.h>
#include <shlwapi.h>
#include <iostream>
#include <objbase.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>

int fuzzMeDrZaus(const uint8_t *Data, size_t size)
{


    PIDLIST_ABSOLUTE pidlAbsolute;
    pidlAbsolute = ILCreateFromPath((PCTSTR) Data)
    SHGetFolderLocation(0, 5, 0, 0, pidlAbsolute);

    return 0;
};


extern "C" int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) {

  fuzzMeDrZaus(Data, Size);
  return 0;
}
```

Notice I'm creating a PIDLIST_ABSOLUTE object pointer and shoving it into SHGetFolderLocation. If we can find a name in which explorer.exe cannot handle or causes some corruption, that's a win. So let's get fuzzing to find that name. We compile:

```
C:\Users\Garrett McParrot\Desktop\0day\shell32an
λ clang-cl.exe /Zi -fsanitize=fuzzer,address -fsanitize-recover=address shell32_pwn_targeted.cpp ole32.lib shell32.lib shlwapi.lib
shell32_pwn_targeted.cpp(18,5): error: no matching function for call to 'SHGetFolderLocation'
    SHGetFolderLocation(0, 5, 0, 0, pidlAbsolute);
    ^~~~~~~~~~~~~~~~~~~
C:\Program Files (x86)\Windows Kits\10\include\10.0.17763.0\um\shlobj_core.h(922,10): note: candidate function not viable: no known conversion from 'LPITEMIDLIST'
      (aka '__unaligned _ITEMIDLIST *') to 'LPITEMIDLIST *' (aka '__unaligned _ITEMIDLIST **') for 5th argument; take the address of the argument with &
SHSTDAPI SHGetFolderLocation(_Reserved_ HWND hwnd, _In_ int csidl, _In_opt_ HANDLE hToken, _In_ DWORD dwFlags, _Outptr_ PIDLIST_ABSOLUTE *ppidl);
         ^
1 error generated.
```

And it won't... looks like that function is in shobj_core.h, so let's add that header. I think we can keep our linked libs the same. And another mistake, I had to be more careful about my pointers:

```
C:\Users\Garrett McParrot\Desktop\0day\shell32an
λ clang-cl.exe /Zi -fsanitize=fuzzer,address -fsanitize-recover=address shell32_pwn_targeted.cpp ole32.lib shell32.lib shlwapi.lib
shell32_pwn_targeted.cpp(17,20): error: incompatible pointer types assigning to 'LPITEMIDLIST *' (aka '__unaligned _ITEMIDLIST **') from 'LPITEMIDLIST'
      (aka '__unaligned _ITEMIDLIST *')
    pidlAbsolute = ILCreateFromPath((PCTSTR) Data);
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Program Files (x86)\Windows Kits\10\include\10.0.17763.0\um\shlobj_core.h(679,33): note: expanded from macro 'ILCreateFromPath'
#define ILCreateFromPath        ILCreateFromPathA
                                ^
1 error generated.

C:\Users\Garrett McParrot\Desktop\0day\shell32an
λ clang-cl.exe /Zi -fsanitize=fuzzer,address -fsanitize-recover=address shell32_pwn_targeted.cpp ole32.lib shell32.lib shlwapi.lib
   Creating library shell32_pwn_targeted.lib and object shell32_pwn_targeted.exp
```






