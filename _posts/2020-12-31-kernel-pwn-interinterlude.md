## Kernel Stuff

So hunting in explorere.exe is all well and good, and I've been enjoying it. However, I need to get ready for a course I'm giving on the 31st of January! If you're not familiar with our HTP green belt course (https://www.hyperiongray.com/htp) we focus heavily on Windows 10 kernel exploitation. We do a bunch of userland stuff as well, but I find that attacking the kernel allows you to analyze small well-structured (and well documented) files. There's been a lot of work in it, and well, there's a reason why last time I approached Zerodium about kernel-based LPEs they weren't buying any more. It's a great place to start hunting. It requies some lead time in learning wtf is going on, if you're used to reversing in userland a driver looks pretty damn weird (WHERE'S MY MAIN() FUNCTION!!!?!?!?!).

Anyway as i'm doing a bit of review I figured - may as wwell write it up eh? OK, so the book I'm using for review is the. The first part of the book is blah blah virtual addressing etc. which seems to come up in every windows internals book. it makes sense, it's important. But anyway I'm not gonna get into that here, I'll more be talking about drivers and how they work.

Ok so threads are the things that run things. What do i mean? Processes are just MANAGERs for threads, the thread is what actually owns a stack, makes syscalls, etc. It's an interesting way of thinking about a system where you could say that a thread can't really do jack shit - it can only ask the kernel to do stuff. Of course there's tons of layers of abstraction, so it's not the usual way of thinking of an OS, but it's useful nonetheless.

The Guard Page is an interesting concept, it's part of what allows processes to think they have their very own full address space. How so? Well, a page is `committed` to a process whenever memory is needed. As the stack grows, it's possible that it outgrows the limits of that page. If it does, it "overflows" into a guard paage and causes an exception. The guard page is then marked as executable and the instruction set can run into this page. I assume that after the new page is committed there is now another guard page that does the same thing.

Devices each have a "Handle" associated with them, e.g. `\\Devices\\vmhgfs`. Most functions trying to "attach" to one return NULL on failure, note this is the opposite of most userspace stuff where a return 0 is usually good. But that's windows. 

Alright so let's jump to doing a little bit of driver analysis and RE work. This is how I got my start doing 0-day hunting so it's nice to be back on familiar ground :-), greetz to ch3f. You're an asshole but you taught me a lot <3.

Anyway I've noticed that there really isn't much to rival IDA in terms of kernel driver (lkm in Linux) analysis. I've tried with Binary Ninja - goddman I've tried, but there is very very little to no autoanalysis, nor are there any good plugins that aren't date. Ghidra is *pretty good*, but requires a bit of tomfuckery. I'd like to skip that tomfuckery which requires importing symbols from the WDK in a weird proprietary format when honestly, if I have the WDK installed the RE program should just use them. They're in my path and e'erything. Anyway, I pop open `C:\Windows\system32\drivers\vmhgfs.sys` and start looking at it. I have the win_driver_plugin installed from here https://github.com/uf0o/win_driver_plugin. Note I have my own for IDA 7.4 amd python 2 here https://gitlab.com/acaceres/win-driver-plugin-7.4. I also ported it to python 3 for IDA 7.5 but to be honest, just use the other dude's. I didn't make sure all of the functionality was working correctly and he seems to have done a great job. So install that thing by dropping the .py file and the library into the IDA plugins/ folder!

![/assets/img/ida_de.PNG](/assets/img/ida_de.PNG)
